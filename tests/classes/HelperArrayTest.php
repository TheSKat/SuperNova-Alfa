<?php

/**
 * Class HelperArrayTest
 *
 * @coversDefaultClass HelperArray
 */
class HelperArrayTest extends PHPUnit_Framework_TestCase {

  public function setUp() {
    parent::setUp(); // TODO: Change the autogenerated stub
  }

  public function tearDown() {
    parent::tearDown(); // TODO: Change the autogenerated stub
  }

  public function dataStringToArray() {
    return array(
      array(123, ',', array()), // Only string would be converted to array
      array('', ',', array()), // Empty data would be converted to empty array()
      array('123', ',', array('123')), // One element string
      array('123,234', ',', array('123', '234')), // Two element string
      array('123;234', ';', array('123', '234')), // Specified delimiter
    );
  }

  /**
   * @param string $value
   * @param string $delimiter
   * @param array  $expected
   *
   * @dataProvider dataStringToArray
   *
   * @covers ::stringToArray
   */
  public function testStringToArray($value, $delimiter, $expected) {
    $this->assertEquals($expected, HelperArray::stringToArray($value, $delimiter));
  }


  public function dataMakeArray() {
    return array(
      array(array('test'), 0, array('test')), // Straightforward: just array
      array('test', 0, array(0 => 'test')), // Value with default index
      array('test', 1, array(1 => 'test')), // Value with non-default index
    );
  }

  /**
   * @dataProvider dataMakeArray
   *
   * @covers ::makeArrayRef
   */
  public function testMakeArrayRef($value, $index, $expected) {
    HelperArray::makeArrayRef($value, $index);
    $this->assertEquals($expected, $value);
  }

  /**
   * @dataProvider dataMakeArray
   *
   * @covers ::makeArray
   */
  public function testMakeArray($value, $index, $expected) {
    $this->assertEquals($expected, HelperArray::makeArray($value, $index));
  }

  public function dataFilter() {
    $callback = function ($value) {
      return !empty($value);
    };

    return array(
      array(1, $callback, array()), // Not array
      array(array(), $callback, array()), // Empty array
      array(array(''), $callback, array()), // Not empty array with one empty element
      array(array('0', ''), $callback, array()), // Not empty array with both filterable elements
      array(array('test', ''), $callback, array(0 => 'test')), // Not empty array with one filterable element
      array(array('test1', '', 'test2'), $callback, array(0 => 'test1', 1 => 'test2')),
      array(array('test1', 'test', 'test2'), $callback, array(0 => 'test1', 1 => 'test', 2 => 'test2')),
    );
  }

  /**
   * @param mixed    $value
   * @param callable $callback
   * @param array    $expected
   *
   * @dataProvider dataFilter
   *
   * @covers ::filter
   */
  public function testFilter($value, $callback, $expected) {
    $this->assertEquals($expected, HelperArray::filter($value, $callback));
  }

  /**
   * @param mixed    $value
   * @param callable $callback
   * @param array    $expected
   *
   * @dataProvider dataFilter
   *
   * @covers ::filterEmpty
   * @covers       Validators::isNotEmpty
   * @covers       Validators::isNotEmptyByRef
   * @covers ::filter
   */
  public function testFilterEmpty($value, $callback, $expected) {
    $this->assertEquals($expected, HelperArray::filterEmpty($value));
  }


  /**
   * @covers ::stringToArrayFilterEmpty
   * @covers ::stringToArray
   * @covers ::filterEmpty
   * @covers Validators::isNotEmpty
   * @covers ::filter
   */
  public function testStringToArrayFilterEmpty() {
    // Not string
    $this->assertEquals(array(), HelperArray::stringToArrayFilterEmpty(1));

    // Empty string
    $this->assertEquals(array(), HelperArray::stringToArrayFilterEmpty(''));
  }

  /**
   * @covers ::merge
   */
  public function testMerge() {
    // Testing ARRAY_REPLACE mode
    $array1 = array('a' => 'b');
    $array2 = array('c' => 'd', 0 => 10);
    HelperArray::merge($array1, $array2);
    $this->assertEquals($array2, $array1);

    // Testing ARRAY_MERGE mode
    // String keyed value should be replaced
    // Integer keyed value should be added and integer keys should be recalculated
    $array2 = array('c' => 'e', 0 => 20);
    HelperArray::merge($array1, $array2, HelperArray::MERGE_PHP);
    $this->assertEquals(array('c' => 'e', 0 => 10, 1 => 20), $array1);

    // First array is not an array
    $array1 = 1;
    // Element int(20) should have key recalculated and become key(2)
    $array2 = array('c' => 'd', 1 => 10, 5 => 20);
    HelperArray::merge($array1, $array2, HelperArray::MERGE_PHP);
    $this->assertEquals(array(0 => 1, 'c' => 'd', 1 => 10, 2 => 20), $array1);

  }

  /**
   * @covers ::keyExistsOr
   */
  public function testKeyExistsOr() {
    $array = array('a' => 'b');
    $this->assertEquals('b', HelperArray::keyExistsOr($array, 'a', 'q'));
    $this->assertEquals('q', HelperArray::keyExistsOr($array, 'c', 'q'));
  }

  public function dataCloneDeep() {
    return array(
      array(HelperArray::CLONE_ARRAY_NONE, true, 2, true, 6),
      array(HelperArray::CLONE_ARRAY_SHALLOW, false, 1, true, 6),
      array(HelperArray::CLONE_ARRAY_RECURSIVE, false, 1, false, 5),
    );
  }

  protected function helpCloneDeep($source, $destination, $isSameObject, $value, $valueAfterChange) {
    // Checking 0-level object
    $this->assertEquals($isSameObject, $source === $destination);

    // Checking property 'test' of 0-level object
    $this->assertEquals($source->test, $destination->test);
    $this->assertEquals($value, $destination->test);
    $this->assertEquals($value, $source->test);

    // Changing property of 0-level and checking result
    $destination->test = $value + 1;
    $this->assertEquals($value + 1, $destination->test);
    $this->assertEquals($valueAfterChange, $source->test);
  }


  /**
   * @dataProvider dataCloneDeep
   *
   * @covers ::cloneDeep
   */
  public function testCloneDeep($deep, $l0Eq, $l0Prop, $l1Eq, $l1Prop) {
    // Init values
    $source = array(new StdClass(), array(new StdClass()));
    $source[0]->test = 1;
    $source[1][0]->test = 5;
    $destination = $source;

    // Making clone
    HelperArray::cloneDeep($destination, $deep);
    $this->helpCloneDeep($source[0], $destination[0], $l0Eq, 1, $l0Prop);
    $this->helpCloneDeep($source[1][0], $destination[1][0], $l1Eq, 5, $l1Prop);
  }

}
